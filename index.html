<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Interactive Klotski Visualizer</title>
<style>
body { margin:0; font-family:sans-serif; background:#111; color:#eee; }
#gridContainer { display:flex; justify-content:center; margin-top:10px; }
#gridCanvas { border:2px solid #555; cursor:crosshair; background:#222; }
#controls { text-align:center; margin:10px; }
#canvas3d { width:100%; height:70vh; display:block; background:#111; }
</style>
</head>
<body>

<h2 style="text-align:center;">Draw up to 5 pieces on 6x6 grid</h2>
<div id="gridContainer">
  <canvas id="gridCanvas" width="360" height="360"></canvas>
</div>
<div id="controls">
  <button id="visualizeBtn">Visualize All Reachable Layouts</button>
</div>
<canvas id="canvas3d"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
<script>
// =========================
//  Grid editor
// =========================
const canvas = document.getElementById('gridCanvas');
const ctx = canvas.getContext('2d');
const GRID = 6;
const CELL = canvas.width / GRID;
let pieces = [];
let pieceColors = ["#e74c3c","#3498db","#2ecc71","#f1c40f","#9b59b6"];
let currentPieceId = 0;
let placing = false;

// Draw grid
function drawGrid(){
  ctx.fillStyle="#222"; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle="#555"; ctx.lineWidth=1;
  for(let i=0;i<=GRID;i++){
    ctx.beginPath();
    ctx.moveTo(i*CELL,0); ctx.lineTo(i*CELL,canvas.height); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0,i*CELL); ctx.lineTo(canvas.width,i*CELL); ctx.stroke();
  }
  // draw pieces
  for(const p of pieces){
    ctx.fillStyle=p.color;
    ctx.fillRect(p.x*CELL,p.y*CELL,p.w*CELL,p.h*CELL);
  }
}
drawGrid();

// Mouse to place pieces
canvas.addEventListener('mousedown', e=>{
  if(currentPieceId>=5) return;
  const rect = canvas.getBoundingClientRect();
  const mx = Math.floor((e.clientX-rect.left)/CELL);
  const my = Math.floor((e.clientY-rect.top)/CELL);
  // simple 1x1 piece
  pieces.push({id:currentPieceId,x:mx,y:my,w:1,h:1,color:pieceColors[currentPieceId]});
  currentPieceId++;
  drawGrid();
});

// =========================
// BFS solver for reachable layouts
// =========================
function serialize(state){ return state.map(p=>`${p.x},${p.y}`).join("|"); }
function cloneState(state){ return state.map(p=>({id:p.id,x:p.x,y:p.y,w:p.w,h:p.h,color:p.color})); }

function valid(state){
  const occ=Array.from({length:GRID},()=>Array(GRID).fill(null));
  for(const p of state){
    if(p.x<0||p.y<0||p.x+p.w>GRID||p.y+p.h>GRID) return false;
    for(let i=0;i<p.w;i++) for(let j=0;j<p.h;j++){
      if(occ[p.y+j][p.x+i]!==null) return false;
      occ[p.y+j][p.x+i]=p.id;
    }
  }
  return true;
}

function neighbors(state){
  const result=[];
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  for(const p of state){
    for(const [dx,dy] of dirs){
      const ns=cloneState(state);
      ns.find(x=>x.id===p.id).x+=dx;
      ns.find(x=>x.id===p.id).y+=dy;
      if(valid(ns)) result.push(ns);
    }
  }
  return result;
}

// BFS all reachable
function computeAllStates(start){
  const visited=new Map();
  const queue=[start];
  visited.set(serialize(start),start);
  const edges=[];
  while(queue.length){
    const cur=queue.shift();
    const nbs=neighbors(cur);
    for(const n of nbs){
      const key=serialize(n);
      if(!visited.has(key)){
        visited.set(key,n);
        queue.push(n);
      }
      edges.push([serialize(cur),key]);
    }
  }
  return {states:Array.from(visited.values()),edges};
}

// =========================
//  Three.js 3D visualization
// =========================
let renderer,scene,camera,controls;
function visualize3D(graph){
  // Clear previous
  if(renderer) renderer.dispose();
  renderer=new THREE.WebGLRenderer({canvas:document.getElementById('canvas3d')});
  renderer.setSize(window.innerWidth,window.innerHeight*0.7);
  scene=new THREE.Scene(); scene.background=new THREE.Color(0x111111);
  camera=new THREE.PerspectiveCamera(60,window.innerWidth/(window.innerHeight*0.7),0.1,5000);
  camera.position.set(30,30,50);
  controls=new THREE.OrbitControls(camera,renderer.domElement);
  controls.enableDamping=true;
  scene.add(new THREE.AmbientLight(0x888888));
  const light=new THREE.DirectionalLight(0xffffff,1); light.position.set(50,50,50); scene.add(light);

  // Layout states in 3D grid
  const posMap=new Map();
  const spacing=4;
  graph.states.forEach((s,i)=>{
    const x=(i%20)*spacing;
    const y=Math.floor(i/400)*spacing;
    const z=Math.floor(i/20)%20*spacing;
    posMap.set(serialize(s),new THREE.Vector3(x,y,z));
    const mesh=new THREE.Mesh(new THREE.SphereGeometry(0.5,12,12),new THREE.MeshStandardMaterial({color:0x3498db}));
    mesh.position.set(x,y,z);
    scene.add(mesh);
  });

  // Edges
  graph.edges.forEach(([a,b])=>{
    const p1=posMap.get(a), p2=posMap.get(b);
    const geom=new THREE.BufferGeometry().setFromPoints([p1,p2]);
    const line=new THREE.Line(geom,new THREE.LineBasicMaterial({color:0x555555}));
    scene.add(line);
  });

  function animate(){
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene,camera);
  }
  animate();
}

// =========================
//  Button to visualize
// =========================
document.getElementById('visualizeBtn').addEventListener('click',()=>{
  if(pieces.length===0){ alert("Place at least one piece!"); return; }
  const graph=computeAllStates(pieces);
  visualize3D(graph);
});
</script>
</body>
</html>
