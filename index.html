<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Sliding Puzzle State Space (3D)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --ui-bg: rgba(0,0,0,.65);
    --ui-br: 12px;
    --ui-fg: #e9eef8;
    --ui-accent: #6ea8fe;
  }
  html, body { height:100%; margin:0; background:#0f1117; color:#e9eef8; font-family:system-ui,Segoe UI,Roboto,Arial; }
  #hud {
    position:fixed; top:12px; left:12px; z-index:10;
    background:var(--ui-bg); padding:12px; border-radius:var(--ui-br); backdrop-filter: blur(6px);
    display:flex; flex-direction:column; gap:8px; width:min(520px, calc(100vw - 24px));
  }
  #hud h1 { font-size:16px; margin:0 0 4px 0; letter-spacing:.2px; }
  .row { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
  label { font-size:12px; opacity:.9; }
  input, button, textarea {
    background:#161a22; color:var(--ui-fg); border:1px solid #2b3054; border-radius:10px; padding:8px 10px; font-size:13px;
  }
  button { cursor:pointer; }
  button.primary { background:var(--ui-accent); color:#0b1025; border-color:transparent; font-weight:700; }
  button.warn { background:#2c2411; border-color:#5a4a1f; color:#ffe9a6; }
  button.ghost { background:#161a22; }
  #status { font-size:12px; opacity:.85; }
  #configArea { width:100%; height:140px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  #mini {
    position:fixed; right:12px; top:12px; width:260px; height:320px; z-index:10;
    background:var(--ui-bg); border-radius:var(--ui-br); backdrop-filter: blur(6px); padding:10px;
  }
  #mini h2 { margin:0 0 6px 0; font-size:13px; }
  #board2d { width:100%; height:calc(100% - 22px); background:#0c0f1c; border-radius:10px; border:1px solid #2b3054; }
  #canvas3d { position:fixed; inset:0; display:block; }
  #legend {
    position:fixed; left:12px; bottom:12px; z-index:10; background:var(--ui-bg); padding:8px 10px; border-radius:var(--ui-br);
    font-size:12px; display:flex; gap:12px; align-items:center;
  }
  .dot { width:12px; height:12px; border-radius:999px; display:inline-block; margin-right:6px; }
</style>
</head>
<body>
  <!-- UI -->
  <div id="hud">
    <h1>Sliding Puzzle State Space (3D)</h1>
    <div class="row">
      <button class="primary" id="buildBtn">Build Graph</button>
      <button class="ghost" id="solveBtn">Solve Shortest Path</button>
      <button class="warn" id="clearBtn">Clear</button>
      <span id="status">Idle</span>
    </div>
    <div class="row">
      <label>Max States <input type="number" id="cap" value="8000" min="100" step="100"></label>
      <label>Layout Spread <input type="number" id="spread" value="2.2" min="0.8" step="0.1"></label>
      <label>Layer Gap <input type="number" id="layerGap" value="1.1" min="0.4" step="0.1"></label>
    </div>
    <textarea id="configArea"></textarea>
    <div class="row">
      <button id="prettyBtn">Pretty-print</button>
      <button id="restoreBtn">Restore Example</button>
    </div>
  </div>

  <div id="mini">
    <h2>State Preview</h2>
    <canvas id="board2d" width="240" height="280"></canvas>
  </div>

  <div id="legend">
    <span><span class="dot" style="background:#2ecc71"></span>Start</span>
    <span><span class="dot" style="background:#f1c40f"></span>Goal</span>
    <span><span class="dot" style="background:#6ea8fe"></span>Other</span>
    <span><span class="dot" style="background:#ff9f43"></span>Shortest-path</span>
  </div>

  <!-- 3D canvas -->
  <canvas id="canvas3d"></canvas>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* =========================
   0) Simple rectangular-piece config
   - Super easy: set board cols/rows
   - Each piece: width (w), height (h), color, start [x,y]
   - Goal: piece id + target [x,y] (top-left of that rect)
========================= */
const EXAMPLE = {
  board: { cols: 4, rows: 5 },
  pieces: {
    A: { w:2, h:2, color:"#e74c3c", start:[1,0] }, // big block
    B: { w:1, h:2, color:"#3498db", start:[0,0] },
    C: { w:1, h:2, color:"#3498db", start:[3,0] },
    D: { w:2, h:1, color:"#2ecc71", start:[0,2] },
    E: { w:1, h:1, color:"#9b59b6", start:[0,4] },
    F: { w:1, h:1, color:"#9b59b6", start:[3,4] }
  },
  goal: { piece:"A", pos:[1,3] }
};

const $ = (s)=>document.querySelector(s);
$("#configArea").value = JSON.stringify(EXAMPLE, null, 2);
$("#restoreBtn").onclick = () => { $("#configArea").value = JSON.stringify(EXAMPLE, null, 2); };
$("#prettyBtn").onclick = () => {
  try { $("#configArea").value = JSON.stringify(JSON.parse($("#configArea").value), null, 2); } catch {}
};

function readConfig(){
  let cfg = JSON.parse($("#configArea").value);
  // normalize hex colors to int for Three.js
  for(const id in cfg.pieces){
    const p = cfg.pieces[id];
    if (typeof p.color === "string" && p.color.startsWith("#")) {
      p.color = parseInt(p.color.slice(1), 16);
    }
  }
  return cfg;
}

/* =========================
   1) State model (rect pieces, 4-dir single-step moves)
========================= */
function initState(cfg){
  const s = {};
  for(const id in cfg.pieces) s[id] = cfg.pieces[id].start.slice();
  return s;
}
function serialize(s){
  // stable order by id
  return Object.keys(s).sort().map(id => id+":"+s[id][0]+","+s[id][1]).join("|");
}
function valid(s, cfg){
  const W = cfg.board.cols, H = cfg.board.rows;
  const occ = Array.from({length:H}, ()=>Array(W).fill(null));
  for(const id in s){
    const [x,y] = s[id];
    const {w,h} = cfg.pieces[id];
    if (x<0 || y<0 || x+w>W || y+h>H) return false;
    for(let i=0;i<w;i++) for(let j=0;j<h;j++){
      if (occ[y+j][x+i]) return false;
      occ[y+j][x+i] = id;
    }
  }
  return true;
}
function neighbors(s, cfg){
  const out=[];
  for(const id in s){
    const [x,y] = s[id];
    for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
      const ns = structuredClone(s);
      ns[id] = [x+dx, y+dy];
      if (valid(ns, cfg)) out.push(ns);
    }
  }
  return out;
}
function isGoal(s, cfg){
  const g = cfg.goal;
  return s[g.piece][0]===g.pos[0] && s[g.piece][1]===g.pos[1];
}

/* =========================
   2) BFS reachability (entire state space up to cap)
========================= */
function buildStateGraph(cfg, cap, onProgress){
  const start = initState(cfg);
  const startKey = serialize(start);
  const queue = [start];
  const parent = new Map();       // childKey -> parentKey
  const depth  = new Map([[startKey, 0]]);
  const seen   = new Set([startKey]);
  const states = new Map([[startKey, start]]);
  const goalKeys = new Set();

  let explored = 0;
  while(queue.length && states.size < cap){
    const cur = queue.shift();
    const curKey = serialize(cur);
    const curDepth = depth.get(curKey) || 0;

    if (isGoal(cur, cfg)) goalKeys.add(curKey);

    for(const n of neighbors(cur, cfg)){
      const k = serialize(n);
      if (!seen.has(k)){
        seen.add(k);
        states.set(k, n);
        parent.set(k, curKey);
        depth.set(k, curDepth+1);
        queue.push(n);
      }
      if (states.size >= cap) break;
    }
    explored++;
    if (onProgress && explored % 250 === 0) onProgress(states.size);
  }

  // Build edge list (parent → child; enough to view connectivity)
  const edges = [];
  for(const [child, par] of parent){
    edges.push([par, child]);
  }

  return { startKey, states, edges, depth, goalKeys };
}

/* =========================
   3) Shortest path (from start to first found goal)
========================= */
function shortestPath(graph){
  const {states, depth, startKey, goalKeys} = graph;
  if (!goalKeys.size) return null;
  // choose shallowest goal
  let bestKey=null, bestDepth=Infinity;
  for(const k of goalKeys){
    const d = depth.get(k) ?? Infinity;
    if (d < bestDepth) { bestDepth = d; bestKey = k; }
  }
  const path = [];
  let cur = bestKey;
  // Reconstruct via parent links (edges are parent->child; rebuild reverse map)
  const parent = new Map();
  for(const [par, child] of graph.edges){
    parent.set(child, par);
  }
  while (cur){
    path.push(cur);
    cur = parent.get(cur);
  }
  return path.reverse(); // start → goal
}

/* =========================
   4) 3D visualization (big canvas, orbit/zoom/pan)
   Layout: nodes arranged by BFS depth in stacked layers.
   Within a layer, nodes placed on a circle (spiral-ish) with jitter.
========================= */
const canvas3d = $("#canvas3d");
const renderer = new THREE.WebGLRenderer({canvas:canvas3d, antialias:true});
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
resize3D();
window.addEventListener("resize", resize3D);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0e16);
const camera = new THREE.PerspectiveCamera(60, canvas3d.clientWidth/canvas3d.clientHeight, 0.1, 5000);
camera.position.set(0, 45, 90);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.minDistance = 10;
controls.maxDistance = 1000;

const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
dirLight.position.set(40, 100, 30);
scene.add(dirLight);
scene.add(new THREE.AmbientLight(0x8899aa, 0.6));

const gridHelper = new THREE.GridHelper(300, 60, 0x334, 0x223);
gridHelper.position.y = -0.5;
scene.add(gridHelper);

// Node storage
let GRAPH = null;
let nodeMeshByKey = new Map();
let lineGroup = new THREE.Group();
scene.add(lineGroup);

const matStart = new THREE.MeshStandardMaterial({ color: 0x2ecc71 });
const matGoal  = new THREE.MeshStandardMaterial({ color: 0xf1c40f });
const matOther = new THREE.MeshStandardMaterial({ color: 0x6ea8fe });
const matPath  = new THREE.MeshStandardMaterial({ color: 0xff9f43 });

const sphereGeom = new THREE.SphereGeometry(0.7, 20, 20);

// Raycaster for clicking nodes
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

/* Layout nodes into 3D positions */
function layoutGraph(graph, spread=2.2, layerGap=1.1){
  const {states, depth} = graph;
  const byDepth = new Map();
  for(const [k] of states){
    const d = depth.get(k) || 0;
    if (!byDepth.has(d)) byDepth.set(d, []);
    byDepth.get(d).push(k);
  }
  // positions:
  const pos = new Map(); // key -> Vector3
  const maxDepth = Math.max(...byDepth.keys());
  for(let d=0; d<=maxDepth; d++){
    const arr = byDepth.get(d) || [];
    const R = Math.max(6, d * 3 * spread);  // radius grows with depth
    const n = Math.max(1, arr.length);
    for(let i=0;i<arr.length;i++){
      const a = (i / n) * Math.PI * 2;
      const jitter = (Math.random()-0.5) * 0.8;
      const x = (R + jitter) * Math.cos(a);
      const z = (R + jitter) * Math.sin(a);
      const y = d * layerGap * 3;
      pos.set(arr[i], new THREE.Vector3(x, y, z));
    }
  }
  return pos;
}

/* Build meshes and lines */
function drawGraph3D(graph, highlightPathKeys=null){
  // clear previous
  for(const m of nodeMeshByKey.values()) scene.remove(m);
  nodeMeshByKey.clear();
  lineGroup.clear();

  const spread = parseFloat($("#spread").value || "2.2");
  const layerGap = parseFloat($("#layerGap").value || "1.1");
  const positions = layoutGraph(graph, spread, layerGap);

  // nodes
  const {startKey, goalKeys} = graph;
  for(const [key, state] of graph.states){
    let mat = matOther;
    if (key === startKey) mat = matStart;
    else if (goalKeys.has(key)) mat = matGoal;

    const mesh = new THREE.Mesh(sphereGeom, mat.clone());
    mesh.position.copy(positions.get(key));
    mesh.userData = { key };
    scene.add(mesh);
    nodeMeshByKey.set(key, mesh);
  }

  // edges
  const lineMat = new THREE.LineBasicMaterial({ color: 0x44506a, transparent:true, opacity:0.7 });
  for(const [a,b] of graph.edges){
    const p1 = nodeMeshByKey.get(a).position;
    const p2 = nodeMeshByKey.get(b).position;
    const geom = new THREE.BufferGeometry().setFromPoints([p1, p2]);
    const line = new THREE.Line(geom, lineMat);
    lineGroup.add(line);
  }

  // optionally highlight a shortest path
  if (highlightPathKeys && highlightPathKeys.length){
    for (let i=0;i<highlightPathKeys.length;i++){
      const k = highlightPathKeys[i];
      const mesh = nodeMeshByKey.get(k);
      if (mesh) mesh.material = matPath.clone();
      if (i>0){
        const p1 = nodeMeshByKey.get(highlightPathKeys[i-1]).position;
        const p2 = nodeMeshByKey.get(k).position;
        const g = new THREE.BufferGeometry().setFromPoints([p1,p2]);
        const l = new THREE.Line(g, new THREE.LineBasicMaterial({ color:0xff9f43, linewidth: 2 }));
        lineGroup.add(l);
      }
    }
  }
}

/* =========================
   5) Mini 2D preview (clicked node state)
========================= */
const board2d = $("#board2d");
const btx = board2d.getContext("2d");

function drawPreview(state, cfg){
  const W = cfg.board.cols, H = cfg.board.rows;
  const cw = board2d.width / W, ch = board2d.height / H;
  // bg
  btx.clearRect(0,0,board2d.width,board2d.height);
  btx.fillStyle = "#0a0e1a"; btx.fillRect(0,0,board2d.width,board2d.height);
  // grid
  btx.strokeStyle = "#1a2140";
  for(let x=0;x<=W;x++){ btx.beginPath(); btx.moveTo(x*cw,0); btx.lineTo(x*cw, H*ch); btx.stroke(); }
  for(let y=0;y<=H;y++){ btx.beginPath(); btx.moveTo(0,y*ch); btx.lineTo(W*cw, y*ch); btx.stroke(); }
  // goal rect
  const g = cfg.goal;
  if (g){
    const pw = cfg.pieces[g.piece].w, ph = cfg.pieces[g.piece].h;
    btx.fillStyle = "rgba(241,196,15,.16)";
    btx.fillRect(g.pos[0]*cw, g.pos[1]*ch, pw*cw, ph*ch);
    btx.strokeStyle = "#f1c40f"; btx.lineWidth = 2;
    btx.strokeRect(g.pos[0]*cw+1, g.pos[1]*ch+1, pw*cw-2, ph*ch-2);
    btx.lineWidth = 1;
  }
  // pieces
  btx.font = `${Math.max(10, Math.floor(Math.min(cw,ch)*0.35))}px ui-monospace, monospace`;
  btx.textAlign = "center"; btx.textBaseline = "middle";
  for(const id in state){
    const [x,y] = state[id];
    const p = readConfig().pieces[id];
    btx.fillStyle = p.color ? "#"+p.color.toString(16).padStart(6,"0") : "#6ea8fe";
    btx.fillRect(x*cw+2, y*ch+2, p.w*cw-4, p.h*ch-4);
    btx.fillStyle = "rgba(0,0,0,.45)";
    btx.fillText(id, x*cw + (p.w*cw)/2, y*ch + (p.h*ch)/2);
  }
}

/* =========================
   6) Interaction + rendering loop
========================= */
function resize3D(){
  const w = window.innerWidth, h = window.innerHeight;
  renderer.setSize(w, h);
  camera.aspect = w/h; camera.updateProjectionMatrix();
}
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

// Click to select a node
renderer.domElement.addEventListener("pointerdown", (e)=>{
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects([...nodeMeshByKey.values()], false);
  if (hits.length){
    const key = hits[0].object.userData.key;
    const s = GRAPH.states.get(key);
    drawPreview(s, readConfig());
  }
});

/* =========================
   7) Buttons
========================= */
$("#buildBtn").onclick = () => {
  try{
    const cfg = readConfig();
    const cap = +($("#cap").value || 8000);
    $("#status").textContent = "Exploring...";
    // build graph (sync; keep cap reasonable)
    const startTime = performance.now();
    GRAPH = buildStateGraph(cfg, cap, (count)=>{
      $("#status").textContent = `Exploring... ${count}/${cap}`;
    });
    const took = ((performance.now()-startTime)/1000).toFixed(2);
    $("#status").textContent = `States: ${GRAPH.states.size} | Edges: ${GRAPH.edges.length} | Depth: ${Math.max(...GRAPH.depth.values())} | ${took}s`;
    drawGraph3D(GRAPH, null);
    // auto show start state
    drawPreview(GRAPH.states.get(GRAPH.startKey), cfg);
  }catch(err){
    $("#status").textContent = "Config error: " + err.message;
  }
};

$("#solveBtn").onclick = () => {
  if (!GRAPH){ $("#status").textContent = "Build the graph first."; return; }
  const path = shortestPath(GRAPH);
  if (!path){ $("#status").textContent = "No goal found in explored space."; return; }
  $("#status").textContent = `Shortest path length: ${path.length-1} moves`;
  drawGraph3D(GRAPH, path);
  // preview goal
  const goalState = GRAPH.states.get(path[path.length-1]);
  drawPreview(goalState, readConfig());
};

$("#clearBtn").onclick = () => {
  // remove nodes/lines
  for(const m of nodeMeshByKey.values()) scene.remove(m);
  nodeMeshByKey.clear();
  lineGroup.clear();
  GRAPH = null;
  $("#status").textContent = "Cleared.";
  // clear mini
  btx.clearRect(0,0,board2d.width,board2d.height);
};
</script>
</body>
</html>
