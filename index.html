<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Klotski Visualizer - Arbitrary Pieces</title>
<style>
body { margin:0; font-family:sans-serif; background:#111; color:#eee; }
#gridContainer { display:flex; justify-content:center; margin-top:10px; }
#gridCanvas { border:2px solid #555; cursor:crosshair; background:#222; }
#controls { text-align:center; margin:10px; }
#canvas3d { width:100%; height:70vh; display:block; background:#111; }
button { margin:0 5px; padding:6px 10px; }
</style>
</head>
<body>

<h2 style="text-align:center;">Draw pieces with arbitrary squares on 6x6 grid</h2>
<div id="gridContainer">
  <canvas id="gridCanvas" width="360" height="360"></canvas>
</div>
<div id="controls">
  <button id="createPieceBtn">Create Piece</button>
  <button id="visualizeBtn">Visualize All Reachable Layouts</button>
</div>
<canvas id="canvas3d"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
// =========================
//  Grid Editor
// =========================
const canvas = document.getElementById('gridCanvas');
const ctx = canvas.getContext('2d');
const GRID = 6;
const CELL = canvas.width / GRID;

let pieces = [];
let pieceColors = ["#e74c3c","#3498db","#2ecc71","#f1c40f","#9b59b6"];
let currentPieceId = 0;

// Current drawing piece
let tempSquares = [];
let drawing = false;

// Draw grid and pieces
function drawGrid(){
  ctx.fillStyle="#222"; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle="#555"; ctx.lineWidth=1;
  for(let i=0;i<=GRID;i++){
    ctx.beginPath(); ctx.moveTo(i*CELL,0); ctx.lineTo(i*CELL,canvas.height); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,i*CELL); ctx.lineTo(canvas.width,i*CELL); ctx.stroke();
  }
  // Draw finalized pieces
  for(const p of pieces){
    ctx.fillStyle=p.color;
    for(const s of p.squares){
      ctx.fillRect(s.x*CELL,s.y*CELL,CELL,CELL);
    }
  }
  // Draw temp squares
  if(tempSquares.length>0){
    ctx.fillStyle=pieceColors[currentPieceId];
    for(const s of tempSquares){
      ctx.fillRect(s.x*CELL,s.y*CELL,CELL,CELL);
    }
  }
}
drawGrid();

// Click to toggle square in temp piece
canvas.addEventListener('click', e=>{
  if(currentPieceId>=5) return;
  const rect = canvas.getBoundingClientRect();
  const mx = Math.floor((e.clientX-rect.left)/CELL);
  const my = Math.floor((e.clientY-rect.top)/CELL);
  // toggle
  const idx = tempSquares.findIndex(s=>s.x===mx && s.y===my);
  if(idx>=0) tempSquares.splice(idx,1);
  else tempSquares.push({x:mx,y:my});
  drawGrid();
});

// Create Piece button
document.getElementById('createPieceBtn').addEventListener('click',()=>{
  if(tempSquares.length===0){ alert("Select at least one square!"); return; }
  pieces.push({id:currentPieceId,squares:[...tempSquares],color:pieceColors[currentPieceId]});
  currentPieceId++;
  tempSquares=[];
  drawGrid();
  if(currentPieceId>=5) document.getElementById('createPieceBtn').disabled=true;
});

// =========================
// BFS solver for reachable layouts
// =========================
function serialize(state){
  return state.map(p=>p.squares.map(s=>s.x+","+s.y).sort().join(";")).join("|");
}
function cloneState(state){
  return state.map(p=>({id:p.id,squares:p.squares.map(s=>({x:s.x,y:s.y})),color:p.color}));
}

function valid(state){
  const occ=Array.from({length:GRID},()=>Array(GRID).fill(null));
  for(const p of state){
    for(const s of p.squares){
      if(s.x<0||s.y<0||s.x>=GRID||s.y>=GRID) return false;
      if(occ[s.y][s.x]!==null) return false;
      occ[s.y][s.x]=p.id;
    }
  }
  return true;
}

function neighbors(state){
  const result=[];
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  for(const p of state){
    for(const [dx,dy] of dirs){
      const ns=cloneState(state);
      const piece = ns.find(x=>x.id===p.id);
      piece.squares.forEach(s=>{s.x+=dx; s.y+=dy;});
      if(valid(ns)) result.push(ns);
    }
  }
  return result;
}

function computeAllStates(start){
  const visited=new Map();
  const queue=[start];
  visited.set(serialize(start),start);
  const edges=[];
  while(queue.length){
    const cur=queue.shift();
    const nbs=neighbors(cur);
    for(const n of nbs){
      const key=serialize(n);
      if(!visited.has(key)){
        visited.set(key,n);
        queue.push(n);
      }
      edges.push([serialize(cur),key]);
    }
  }
  return {states:Array.from(visited.values()),edges};
}

// =========================
//  Three.js 3D visualization
// =========================
let renderer,scene,camera,controls;
function visualize3D(graph){
  if(renderer) renderer.dispose();
  renderer=new THREE.WebGLRenderer({canvas:document.getElementById('canvas3d')});
  renderer.setSize(window.innerWidth,window.innerHeight*0.7);
  scene=new THREE.Scene(); scene.background=new THREE.Color(0x111111);
  camera=new THREE.PerspectiveCamera(60,window.innerWidth/(window.innerHeight*0.7),0.1,5000);
  camera.position.set(30,30,50);
  controls=new THREE.OrbitControls(camera,renderer.domElement);
  controls.enableDamping=true;
  scene.add(new THREE.AmbientLight(0x888888));
  const light=new THREE.DirectionalLight(0xffffff,1); light.position.set(50,50,50); scene.add(light);

  // Layout states in 3D grid
  const posMap=new Map();
  const spacing=4;
  graph.states.forEach((s,i)=>{
    const x=(i%20)*spacing;
    const y=Math.floor(i/400)*spacing;
    const z=Math.floor(i/20)%20*spacing;
    posMap.set(serialize(s),new THREE.Vector3(x,y,z));
    const mesh=new THREE.Mesh(new THREE.SphereGeometry(0.5,12,12),new THREE.MeshStandardMaterial({color:0x3498db}));
    mesh.position.set(x,y,z);
    scene.add(mesh);
  });

  // Edges
  graph.edges.forEach(([a,b])=>{
    const p1=posMap.get(a), p2=posMap.get(b);
    const geom=new THREE.BufferGeometry().setFromPoints([p1,p2]);
    const line=new THREE.Line(geom,new THREE.LineBasicMaterial({color:0x555555}));
    scene.add(line);
  });

  function animate(){
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene,camera);
  }
  animate();
}

// =========================
//  Visualize button
// =========================
document.getElementById('visualizeBtn').addEventListener('click',()=>{
  if(pieces.length===0){ alert("Create at least one piece!"); return; }

  console.log("Computing reachable states...");
  const graph = computeAllStates(pieces);
  console.log(`Total states: ${graph.states.length}, edges: ${graph.edges.length}`);

  // Clear previous scene if exists
  if(renderer){
    renderer.forceContextLoss();
    renderer.domElement = null;
    renderer.dispose();
  }

  // Initialize Three.js
  renderer = new THREE.WebGLRenderer({canvas:document.getElementById('canvas3d')});
  renderer.setSize(window.innerWidth, window.innerHeight*0.7);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth/(window.innerHeight*0.7), 0.1, 5000);
  camera.position.set(30,30,50);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  scene.add(new THREE.AmbientLight(0x888888));
  const light = new THREE.DirectionalLight(0xffffff,1);
  light.position.set(50,50,50);
  scene.add(light);

  // Layout states
  const posMap = new Map();
  const spacing = 4;
  graph.states.forEach((s,i)=>{
    const x=(i%20)*spacing;
    const y=Math.floor(i/400)*spacing;
    const z=Math.floor(i/20)%20*spacing;
    posMap.set(serialize(s), new THREE.Vector3(x,y,z));
    const mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.5,12,12),
      new THREE.MeshStandardMaterial({color:0x3498db})
    );
    mesh.position.set(x,y,z);
    scene.add(mesh);
  });

  // Add edges
  graph.edges.forEach(([a,b])=>{
    const p1 = posMap.get(a), p2 = posMap.get(b);
    const geom = new THREE.BufferGeometry().setFromPoints([p1,p2]);
    const line = new THREE.Line(geom, new THREE.LineBasicMaterial({color:0x555555}));
    scene.add(line);
  });

  // Animate
  function animate(){
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene,camera);
  }
  animate();
});

</script>
</body>
</html>
