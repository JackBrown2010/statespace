<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Sliding Puzzle Explorer</title>
<style>
body { margin:0; font-family:sans-serif; background:#0f1117; color:#eee; }
#tabs { display:flex; background:#222; }
.tab { padding:10px 20px; cursor:pointer; color:#aaa; background:#222; }
.tab.active { color:#fff; background:#333; }
#content { height:calc(100vh - 40px); }
.tabContent { display:none; padding:10px; height:100%; overflow:auto; }
textarea { width:100%; font-family:monospace; background:#111; color:#eee; border:1px solid #333; }
button { margin-top:6px; padding:6px 10px; }
#canvas3d { width:100%; height:100%; display:block; }
#mini { position:fixed; right:10px; top:50px; width:240px; height:280px; background:rgba(0,0,0,0.6); border-radius:12px; padding:8px; }
#board2d { width:100%; height:100%; background:#0c0f1c; }
</style>
</head>
<body>
<div id="tabs">
  <div id="tabConfig" class="tab active">Board Setup</div>
  <div id="tabViewer" class="tab">State Space</div>
</div>

<div id="content">
  <!-- Board editor -->
  <div id="boardTab" class="tabContent" style="display:block;">
    <h3>Board Setup</h3>
    <label>Cols: <input id="cols" type="number" value="4"></label>
    <label>Rows: <input id="rows" type="number" value="5"></label>
    <p>Pieces JSON:</p>
    <textarea id="pieces" rows="10">{
  "A": {"w":2,"h":2,"color":"#e74c3c","start":[1,0]},
  "B": {"w":1,"h":2,"color":"#3498db","start":[0,0]},
  "C": {"w":2,"h":1,"color":"#2ecc71","start":[0,2]},
  "D": {"w":1,"h":1,"color":"#f1c40f","start":[3,0]}
}</textarea>
    <p>Goal JSON:</p>
    <textarea id="goal" rows="2">{"piece":"A","pos":[1,3]}</textarea>
    <button id="saveBtn">Save Config</button>
  </div>

  <!-- State space viewer -->
  <div id="stateTab" class="tabContent">
    <button id="generateBtn">Generate State Space</button>
    <canvas id="canvas3d"></canvas>
    <div id="mini">
      <canvas id="board2d"></canvas>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
<script>
/* =========================
   Tab system
========================= */
function showTab(tab){
  document.getElementById("boardTab").style.display = tab==='board'?'block':'none';
  document.getElementById("stateTab").style.display = tab==='state'?'block':'none';
  document.getElementById("tabConfig").classList.toggle("active", tab==='board');
  document.getElementById("tabViewer").classList.toggle("active", tab==='state');
  if(tab==='state' && !window.stateSpaceInit){
    initStateSpace(); window.stateSpaceInit=true;
  }
}
document.getElementById("tabConfig").onclick=()=>showTab("board");
document.getElementById("tabViewer").onclick=()=>showTab("state");

/* =========================
   Puzzle config
========================= */
let puzzleConfig = {};
function loadConfig(){
  puzzleConfig.board={cols:parseInt(document.getElementById("cols").value), rows:parseInt(document.getElementById("rows").value)};
  puzzleConfig.pieces=JSON.parse(document.getElementById("pieces").value);
  puzzleConfig.goal=JSON.parse(document.getElementById("goal").value);
}
document.getElementById("saveBtn").onclick=()=>{
  loadConfig(); alert("Config saved!");
};
loadConfig();

/* =========================
   Solver & State-space Graph
========================= */
// --- State representation
function initState(){ let s={}; for(let p in puzzleConfig.pieces) s[p]=[...puzzleConfig.pieces[p].start]; return s; }
function serialize(s){ return Object.keys(s).sort().map(id=>id+":"+s[id][0]+","+s[id][1]).join("|"); }
function valid(s){
  const W=puzzleConfig.board.cols,H=puzzleConfig.board.rows;
  const occ=Array.from({length:H},()=>Array(W).fill(null));
  for(let id in s){
    const [x,y]=s[id]; const {w,h}=puzzleConfig.pieces[id];
    if(x<0||y<0||x+w>W||y+h>H) return false;
    for(let i=0;i<w;i++)for(let j=0;j<h;j++){ if(occ[y+j][x+i]) return false; occ[y+j][x+i]=id; }
  }
  return true;
}
function neighbors(s){
  let out=[];
  for(let id in s){
    const [x,y]=s[id];
    for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
      let ns=structuredClone(s); ns[id]=[x+dx,y+dy];
      if(valid(ns)) out.push(ns);
    }
  }
  return out;
}
function isGoal(s){ const g=puzzleConfig.goal; return s[g.piece][0]===g.pos[0] && s[g.piece][1]===g.pos[1]; }

// --- BFS / Graph
function buildStateGraph(cap=10000){
  const start=initState(), startKey=serialize(start);
  const queue=[start], seen=new Set([startKey]), depth=new Map([[startKey,0]]);
  const parent=new Map(), states=new Map([[startKey,start]]), goalKeys=new Set();
  while(queue.length && states.size<cap){
    const cur=queue.shift(), curKey=serialize(cur), curDepth=depth.get(curKey);
    if(isGoal(cur)) goalKeys.add(curKey);
    for(const n of neighbors(cur)){
      const k=serialize(n);
      if(!seen.has(k)){
        seen.add(k);
        states.set(k,n);
        parent.set(k,curKey);
        depth.set(k,curDepth+1);
        queue.push(n);
      }
      if(states.size>=cap) break;
    }
  }
  const edges=[]; for(const [c,p] of parent) edges.push([p,c]);
  return {startKey,states,edges,depth,goalKeys};
}
function shortestPath(graph){
  const {startKey,edges,goalKeys,depth} = graph;
  if(!goalKeys.size) return null;
  let bestKey=null, bestDepth=Infinity;
  for(const k of goalKeys){ const d=depth.get(k); if(d<bestDepth){bestDepth=d;bestKey=k;} }
  const path=[]; const parent=new Map(edges.map(([p,c])=>[c,p]));
  let cur=bestKey; while(cur){ path.push(cur); cur=parent.get(cur); }
  return path.reverse();
}

/* =========================
   Three.js Visualization
========================= */
let renderer, scene, camera, controls, nodeMeshByKey, lineGroup;
let GRAPH=null;
const matStart=new THREE.MeshStandardMaterial({color:0x2ecc71});
const matGoal=new THREE.MeshStandardMaterial({color:0xf1c40f});
const matOther=new THREE.MeshStandardMaterial({color:0x6ea8fe});
const matPath=new THREE.MeshStandardMaterial({color:0xff9f43});
const sphereGeom=new THREE.SphereGeometry(0.7,20,20);
const board2d=document.getElementById("board2d");
const btx=board2d.getContext("2d");

function initStateSpace(){
  // Three.js init
  const canvas3d=document.getElementById("canvas3d");
  renderer=new THREE.WebGLRenderer({canvas:canvas3d,antialias:true});
  renderer.setSize(window.innerWidth,window.innerHeight-40);
  scene=new THREE.Scene(); scene.background=new THREE.Color(0x0b0e16);
  camera=new THREE.PerspectiveCamera(60,canvas3d.clientWidth/canvas3d.clientHeight,0.1,5000);
  camera.position.set(0,45,90);
  controls=new THREE.OrbitControls(camera,renderer.domElement);
  controls.enableDamping=true;
  const light=new THREE.DirectionalLight(0xffffff,1); light.position.set(40,100,30); scene.add(light);
  scene.add(new THREE.AmbientLight(0x8899aa,0.6));
  const grid=new THREE.GridHelper(300,60,0x334,0x223); grid.position.y=-0.5; scene.add(grid);
  nodeMeshByKey=new Map(); lineGroup=new THREE.Group(); scene.add(lineGroup);

  document.getElementById("generateBtn").onclick=()=>{
    loadConfig();
    GRAPH=buildStateGraph(8000);
    drawGraph3D(GRAPH);
    drawPreview(GRAPH.states.get(GRAPH.startKey));
  };

  animate();
}

function layoutGraph(graph,spread=2.2,layerGap=1.1){
  const byDepth=new Map(); for(const k of graph.states.keys()){ const d=graph.depth.get(k); if(!byDepth.has(d)) byDepth.set(d,[]); byDepth.get(d).push(k); }
  const pos=new Map(); const maxDepth=Math.max(...byDepth.keys());
  for(let d=0; d<=maxDepth; d++){
    const arr=byDepth.get(d)||[], R=Math.max(6,d*3*spread), n=Math.max(1,arr.length);
    for(let i=0;i<arr.length;i++){
      const a=(i/n)*Math.PI*2, jitter=(Math.random()-0.5)*0.8;
      pos.set(arr[i], new THREE.Vector3((R+jitter)*Math.cos(a), d*layerGap*3, (R+jitter)*Math.sin(a)));
    }
  }
  return pos;
}

function drawGraph3D(graph,pathKeys=null){
  for(const m of nodeMeshByKey.values()) scene.remove(m); nodeMeshByKey.clear(); lineGroup.clear();
  const positions=layoutGraph(graph);
  for(const [key,state] of graph.states){
    let mat=matOther; if(key===graph.startKey) mat=matStart; else if(graph.goalKeys.has(key)) mat=matGoal;
    const mesh=new THREE.Mesh(sphereGeom,mat.clone()); mesh.position.copy(positions.get(key)); mesh.userData={key}; scene.add(mesh); nodeMeshByKey.set(key,mesh);
  }
  for(const [a,b] of graph.edges){
    const p1=nodeMeshByKey.get(a).position, p2=nodeMeshByKey.get(b).position;
    const geom=new THREE.BufferGeometry().setFromPoints([p1,p2]);
    const line=new THREE.Line(geom,new THREE.LineBasicMaterial({color:0x44506a,transparent:true,opacity:0.7}));
    lineGroup.add(line);
  }
  if(pathKeys && pathKeys.length){
    for(let i=0;i<pathKeys.length;i++){
      const mesh=nodeMeshByKey.get(pathKeys[i]); if(mesh) mesh.material=matPath.clone();
      if(i>0){
